<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Web Remote Desktop</title>
  <style>
    body { margin: 0; background: #111; color: #fff; font-family: Arial; }
    #screen { width: 100vw; height: 100vh; background: #000; cursor: crosshair; }
    #panel {
      position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7);
      padding: 10px; border-radius: 6px; z-index: 10;
    }
    button { margin: 4px; }
  </style>
</head>
<body>

<div id="panel">
  <label for="serverUrl">Server URL:</label>
  <input id="serverUrl" type="text" value="" size="28" placeholder="http://localhost:8000" />
  <label for="sessionId">Session:</label>
  <input id="sessionId" type="text" value="default-session" size="16" />
  <label for="authToken">Token:</label>
  <input id="authToken" type="text" placeholder="optional" size="16" />
  <button id="connectButton">Connect</button>
  <span id="status"></span>
</div>

<video id="screen" autoplay playsinline></video>

<script>
const CONTROL_ACTION = 'control';
const CONTROL_TYPES = {
  mouseMove: 'mouse_move',
  mouseClick: 'mouse_click',
  keypress: 'keypress'
};

let pc;
let dataChannel;
let signalingSocket;
let iceConfig = { iceServers: [] };

const statusEl = document.getElementById('status');
const serverUrlInput = document.getElementById('serverUrl');
if (!serverUrlInput.value) {
  if (window.location.protocol.startsWith('http')) {
    serverUrlInput.value = window.location.origin;
  } else {
    serverUrlInput.value = 'http://localhost:8000';
  }
}

function setStatus(message) {
  statusEl.textContent = message;
}

function ensureChannelOpen() {
  return dataChannel && dataChannel.readyState === 'open';
}

function sendControl(payload) {
  if (!ensureChannelOpen()) return;
  dataChannel.send(JSON.stringify({ action: CONTROL_ACTION, ...payload }));
}

async function loadIceConfig(apiBase, authToken) {
  const headers = authToken ? { 'x-rc-token': authToken } : {};
  try {
    const response = await fetch(`${apiBase}/ice-config`, { headers });
    if (!response.ok) {
      throw new Error('Failed to load ICE config');
    }
    const payload = await response.json();
    if (payload && Array.isArray(payload.iceServers)) {
      return { iceServers: payload.iceServers };
    }
  } catch (error) {
    console.warn('ICE config unavailable, using defaults.', error);
  }
  return { iceServers: [] };
}

async function connect() {
  setStatus('Connecting...');
  const apiBase = document.getElementById('serverUrl').value.trim() || 'http://localhost:8000';
  const sessionId = document.getElementById('sessionId').value.trim() || 'default-session';
  const authToken = document.getElementById('authToken').value.trim();
  iceConfig = await loadIceConfig(apiBase, authToken);
  const apiUrl = new URL(apiBase);
  const wsProtocol = apiUrl.protocol === 'https:' ? 'wss:' : 'ws:';
  const tokenParam = authToken ? `&token=${encodeURIComponent(authToken)}` : '';
  const wsUrl = `${wsProtocol}//${apiUrl.host}/ws?session_id=${encodeURIComponent(sessionId)}&role=browser${tokenParam}`;

  signalingSocket = new WebSocket(wsUrl);
  signalingSocket.onclose = () => setStatus('Disconnected');
  signalingSocket.onerror = () => setStatus('Connection failed');
  signalingSocket.onmessage = async (event) => {
    const payload = JSON.parse(event.data);
    if (payload.type === 'answer') {
      await pc.setRemoteDescription(payload);
      registerControls();
    } else if (payload.type === 'ice' && payload.candidate) {
      await pc.addIceCandidate({
        candidate: payload.candidate,
        sdpMid: payload.sdpMid,
        sdpMLineIndex: payload.sdpMLineIndex
      });
    }
  };

  signalingSocket.onopen = async () => {
    pc = new RTCPeerConnection(iceConfig);
    signalingSocket.send(JSON.stringify({
      type: 'register',
      session_id: sessionId,
      role: 'browser',
      token: authToken || undefined
    }));

    pc.ontrack = (event) => {
      document.getElementById('screen').srcObject = event.streams[0];
    };
    pc.onicecandidate = (event) => {
      if (event.candidate) {
        signalingSocket.send(JSON.stringify({
          type: 'ice',
          session_id: sessionId,
          candidate: event.candidate.candidate,
          sdpMid: event.candidate.sdpMid,
          sdpMLineIndex: event.candidate.sdpMLineIndex
        }));
      }
    };

    pc.addTransceiver('video', { direction: 'recvonly' });
    pc.addTransceiver('audio', { direction: 'recvonly' });

    dataChannel = pc.createDataChannel('control');
    dataChannel.onopen = () => setStatus('Connected');
    dataChannel.onclose = () => setStatus('Disconnected');

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    signalingSocket.send(JSON.stringify(pc.localDescription));
  };
}

function registerControls() {
  const video = document.getElementById('screen');

  video.addEventListener('mousemove', (event) => {
    sendControl({
      type: CONTROL_TYPES.mouseMove,
      x: event.offsetX,
      y: event.offsetY
    });
  });

  video.addEventListener('click', (event) => {
    sendControl({
      type: CONTROL_TYPES.mouseClick,
      x: event.offsetX,
      y: event.offsetY,
      button: 'left'
    });
  });

  window.addEventListener('keydown', (event) => {
    sendControl({
      type: CONTROL_TYPES.keypress,
      key: event.key
    });
  });
}

document.getElementById('connectButton').addEventListener('click', connect);
</script>
</body>
</html>
