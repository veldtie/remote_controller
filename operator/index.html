<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Web Remote Desktop</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Space+Grotesk:wght@400;500;600;700&display=swap"
    rel="stylesheet"
  />
  <link rel="stylesheet" href="styles.css" />
</head>
<body class="manage-mode">
  <div id="hud">
    <div class="hud-section">
      <div class="section-title">Session</div>
      <div class="fields">
        <div class="field">
          <label for="serverUrl">Server URL</label>
          <input id="serverUrl" type="text" value="" placeholder="http://localhost:8000" />
        </div>
        <div class="field">
          <label for="sessionId">Session</label>
          <input id="sessionId" type="text" value="default-session" />
        </div>
        <div class="field">
          <label for="authToken">Token</label>
          <input id="authToken" type="text" placeholder="optional" />
        </div>
        <div class="field">
          <label for="e2eeKey">E2EE Key</label>
          <input id="e2eeKey" type="password" placeholder="optional" autocomplete="off" />
        </div>
      </div>
    </div>

    <div class="hud-section">
      <div class="section-title">Interaction</div>
      <div class="toggle-row">
        <span class="toggle-label">View</span>
        <label class="switch">
          <input id="interactionToggle" type="checkbox" checked />
          <span class="slider"></span>
        </label>
        <span class="toggle-label">Manage</span>
      </div>
      <div id="interactionState" class="hint">Managing</div>
    </div>

    <div class="hud-actions">
      <button id="connectButton" type="button">Connect</button>
      <button id="storageToggle" class="ghost" type="button">Storage</button>
      <span id="status" data-state="">Idle</span>
    </div>
  </div>

  <div id="storageDrawer" aria-hidden="true">
    <div class="drawer-header">
      <div>
        <div class="drawer-title">Remote Storage</div>
        <div class="drawer-subtitle">Browse files and download to this device</div>
      </div>
      <button id="storageClose" class="ghost" type="button">Close</button>
    </div>
    <div class="drawer-body">
      <div class="pane">
        <div class="pane-title">Remote device</div>
        <div class="path-row">
          <input id="remotePathInput" type="text" value="." />
          <button id="remoteGo" class="secondary" type="button">Go</button>
        </div>
        <div class="path-actions">
          <button id="remoteUp" class="ghost small" type="button">Up</button>
          <button id="remoteRefresh" class="ghost small" type="button">Refresh</button>
        </div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>Name</th>
                <th>Size</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="remoteFileList">
              <tr>
                <td colspan="3" class="empty-state">Not connected</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="pane-footer">
          <span id="remoteStatus" data-state="">Idle</span>
        </div>
      </div>
      <div class="pane">
        <div class="pane-title">Local downloads</div>
        <ul id="downloadList" class="download-list">
          <li class="empty-state">No downloads yet</li>
        </ul>
        <div class="pane-footer">
          <span id="downloadStatus" data-state="">Waiting for a download</span>
        </div>
      </div>
    </div>
  </div>

  <div id="modeBadge" class="mode-badge">Manage mode</div>
  <video id="screen" autoplay playsinline></video>

<<<<<<< HEAD
  <script>
    const CONTROL_ACTION = "control";
    const CONTROL_TYPES = {
      mouseMove: "mouse_move",
      mouseClick: "mouse_click",
      keypress: "keypress"
    };
    const E2EE_STORAGE_KEY = "rc_e2ee_passphrase";
    const E2EE_PBKDF2_ITERS = 150000;
    const E2EE_SALT_PREFIX = "remote-controller:";
    const textEncoder = new TextEncoder();
    const textDecoder = new TextDecoder();

    let peerConnection;
    let controlChannel;
    let signalingWebSocket;
    let rtcConfig = { iceServers: [] };
    let controlEnabled = true;
    let controlsBound = false;
    let remoteCurrentPath = ".";
    let pendingDownload = null;
    let isConnected = false;
    let e2eeContext = null;

    const statusEl = document.getElementById("status");
    const serverUrlInput = document.getElementById("serverUrl");
    const sessionIdInput = document.getElementById("sessionId");
    const authTokenInput = document.getElementById("authToken");
    const e2eeKeyInput = document.getElementById("e2eeKey");
    const interactionToggle = document.getElementById("interactionToggle");
    const interactionState = document.getElementById("interactionState");
    const modeBadge = document.getElementById("modeBadge");
    const storageToggle = document.getElementById("storageToggle");
    const storageClose = document.getElementById("storageClose");
    const storageDrawer = document.getElementById("storageDrawer");
    const remotePathInput = document.getElementById("remotePathInput");
    const remoteFileList = document.getElementById("remoteFileList");
    const remoteStatus = document.getElementById("remoteStatus");
    const downloadStatus = document.getElementById("downloadStatus");
    const downloadList = document.getElementById("downloadList");
    const screenEl = document.getElementById("screen");

    if (!serverUrlInput.value) {
      if (window.location.protocol.startsWith("http")) {
        serverUrlInput.value = window.location.origin;
      } else {
        serverUrlInput.value = "http://localhost:8000";
      }
    }

    if (e2eeKeyInput) {
      const storedPassphrase = sessionStorage.getItem(E2EE_STORAGE_KEY);
      if (!e2eeKeyInput.value && storedPassphrase) {
        e2eeKeyInput.value = storedPassphrase;
      }
    }

    function setStatus(message, state = "") {
      statusEl.textContent = message;
      statusEl.dataset.state = state;
    }

    function setRemoteStatus(message, state = "") {
      remoteStatus.textContent = message;
      remoteStatus.dataset.state = state;
    }

    function setDownloadStatus(message, state = "") {
      downloadStatus.textContent = message;
      downloadStatus.dataset.state = state;
    }

    function setConnected(state) {
      isConnected = state;
      if (!state) {
        setRemoteStatus("Not connected", "warn");
      }
    }

    function updateInteractionMode() {
      controlEnabled = interactionToggle.checked;
      const label = controlEnabled ? "Managing" : "Viewing";
      interactionState.textContent = label;
      modeBadge.textContent = controlEnabled ? "Manage mode" : "View only";
      document.body.classList.toggle("manage-mode", controlEnabled);
      document.body.classList.toggle("view-mode", !controlEnabled);
    }

    updateInteractionMode();

    function isSecureCryptoAvailable() {
      return window.isSecureContext && window.crypto && window.crypto.subtle;
    }

    function isE2eeEnvelope(payload) {
      return payload && payload.e2ee === 1 && payload.nonce && payload.ciphertext;
    }

    function base64EncodeBytes(bytes) {
      const chunkSize = 0x8000;
      let binary = "";
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        binary += String.fromCharCode(...chunk);
      }
      return btoa(binary);
    }

    function base64DecodeBytes(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    async function deriveE2eeKey(passphrase, sessionId) {
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        textEncoder.encode(passphrase),
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
      );
      const salt = textEncoder.encode(`${E2EE_SALT_PREFIX}${sessionId}`);
      return crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt,
          iterations: E2EE_PBKDF2_ITERS,
          hash: "SHA-256"
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
      );
    }

    async function encryptE2ee(plaintext) {
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        e2eeContext.key,
        textEncoder.encode(plaintext)
      );
      return JSON.stringify({
        e2ee: 1,
        nonce: base64EncodeBytes(iv),
        ciphertext: base64EncodeBytes(new Uint8Array(ciphertext))
      });
    }

    async function decryptE2ee(envelope) {
      if (!isE2eeEnvelope(envelope)) {
        throw new Error("E2EE envelope required.");
      }
      const iv = base64DecodeBytes(envelope.nonce);
      const ciphertext = base64DecodeBytes(envelope.ciphertext);
      const plaintext = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv },
        e2eeContext.key,
        ciphertext
      );
      return textDecoder.decode(plaintext);
    }

    async function prepareE2ee(sessionId) {
      if (!e2eeKeyInput) {
        e2eeContext = null;
        return;
      }
      const passphrase = e2eeKeyInput.value.trim();
      if (!passphrase) {
        e2eeContext = null;
        return;
      }
      if (!isSecureCryptoAvailable()) {
        throw new Error("E2EE requires HTTPS or localhost.");
      }
      const key = await deriveE2eeKey(passphrase, sessionId);
      e2eeContext = { key };
    }

    async function encodeOutgoing(payload) {
      const message = typeof payload === "string" ? payload : JSON.stringify(payload);
      if (!e2eeContext) {
        return message;
      }
      return encryptE2ee(message);
    }

    async function normalizeIncomingData(data) {
      if (typeof data === "string") {
        return data;
      }
      if (data instanceof ArrayBuffer) {
        return textDecoder.decode(data);
      }
      if (ArrayBuffer.isView(data)) {
        const view = data;
        return textDecoder.decode(view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength));
      }
      if (data instanceof Blob) {
        return data.text();
      }
      return "";
    }

    async function decodeIncoming(data) {
      const text = await normalizeIncomingData(data);
      if (!text) {
        throw new Error("Empty payload.");
      }
      if (!e2eeContext) {
        let parsed = null;
        try {
          parsed = JSON.parse(text);
        } catch (error) {
          parsed = null;
        }
        if (parsed && isE2eeEnvelope(parsed)) {
          throw new Error("E2EE key required.");
        }
        return text;
      }

      let envelope;
      try {
        envelope = JSON.parse(text);
      } catch (error) {
        throw new Error("E2EE envelope required.");
      }
      if (!isE2eeEnvelope(envelope)) {
        throw new Error("E2EE envelope required.");
      }
      return decryptE2ee(envelope);
    }

    function ensureChannelOpen() {
      return controlChannel && controlChannel.readyState === "open";
    }

    async function sendControl(payload) {
      if (!ensureChannelOpen() || !controlEnabled) {
        return;
      }
      try {
        const message = await encodeOutgoing({ action: CONTROL_ACTION, ...payload });
        controlChannel.send(message);
      } catch (error) {
        setStatus(`E2EE error: ${error.message}`, "bad");
      }
    }

    async function loadIceConfig(apiBase, authToken) {
      const headers = authToken ? { "x-rc-token": authToken } : {};
      try {
        const response = await fetch(`${apiBase}/ice-config`, { headers });
        if (!response.ok) {
          throw new Error("Failed to load ICE config");
        }
        const payload = await response.json();
        if (payload && Array.isArray(payload.iceServers)) {
          return { iceServers: payload.iceServers };
        }
      } catch (error) {
        console.warn("ICE config unavailable, using defaults.", error);
      }
      return { iceServers: [] };
    }

    function cleanupConnection() {
      if (controlChannel) {
        controlChannel.onclose = null;
        try {
          controlChannel.close();
        } catch (error) {
          console.warn("Failed to close data channel", error);
        }
      }
      if (peerConnection) {
        try {
          peerConnection.close();
        } catch (error) {
          console.warn("Failed to close peer connection", error);
        }
      }
      if (signalingWebSocket) {
        signalingWebSocket.onclose = null;
        signalingWebSocket.onerror = null;
        try {
          signalingWebSocket.close();
        } catch (error) {
          console.warn("Failed to close signaling socket", error);
        }
      }
      controlChannel = null;
      peerConnection = null;
      signalingWebSocket = null;
    }

    async function connect() {
      setStatus("Connecting...", "warn");
      setConnected(false);
      cleanupConnection();

      const apiBase = serverUrlInput.value.trim() || "http://localhost:8000";
      const sessionId = sessionIdInput.value.trim() || "default-session";
      const authToken = authTokenInput.value.trim();

      try {
        await prepareE2ee(sessionId);
      } catch (error) {
        const reason = error && error.message ? error.message : "E2EE unavailable";
        setStatus(reason, "bad");
        return;
      }

      rtcConfig = await loadIceConfig(apiBase, authToken);
      const apiUrl = new URL(apiBase);
      const wsProtocol = apiUrl.protocol === "https:" ? "wss:" : "ws:";
      const tokenParam = authToken ? `&token=${encodeURIComponent(authToken)}` : "";
      const wsUrl = `${wsProtocol}//${apiUrl.host}/ws?session_id=${encodeURIComponent(sessionId)}&role=browser${tokenParam}`;

      signalingWebSocket = new WebSocket(wsUrl);
      signalingWebSocket.onclose = () => {
        setStatus("Disconnected", "bad");
        setConnected(false);
      };
      signalingWebSocket.onerror = () => {
        setStatus("Connection failed", "bad");
        setConnected(false);
      };
      signalingWebSocket.onmessage = async (event) => {
        const payload = JSON.parse(event.data);
        if (payload.type === "answer") {
          await peerConnection.setRemoteDescription(payload);
          registerControls();
        } else if (payload.type === "ice" && payload.candidate) {
          await peerConnection.addIceCandidate({
            candidate: payload.candidate,
            sdpMid: payload.sdpMid,
            sdpMLineIndex: payload.sdpMLineIndex
          });
        }
      };

      signalingWebSocket.onopen = async () => {
        peerConnection = new RTCPeerConnection(rtcConfig);
        signalingWebSocket.send(JSON.stringify({
          type: "register",
          session_id: sessionId,
          role: "browser",
          token: authToken || undefined
        }));

        peerConnection.ontrack = (event) => {
          screenEl.srcObject = event.streams[0];
        };
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            signalingWebSocket.send(JSON.stringify({
              type: "ice",
              session_id: sessionId,
              candidate: event.candidate.candidate,
              sdpMid: event.candidate.sdpMid,
              sdpMLineIndex: event.candidate.sdpMLineIndex
            }));
          }
        };

        peerConnection.addTransceiver("video", { direction: "recvonly" });
        peerConnection.addTransceiver("audio", { direction: "recvonly" });

        controlChannel = peerConnection.createDataChannel("control");
        controlChannel.onopen = () => {
          const label = e2eeContext ? "Connected (E2EE)" : "Connected";
          setStatus(label, "ok");
          setConnected(true);
          if (storageDrawer.classList.contains("open")) {
            void requestRemoteList(remoteCurrentPath);
          }
        };
        controlChannel.onclose = () => {
          setStatus("Disconnected", "bad");
          setConnected(false);
        };
        controlChannel.onmessage = (event) => {
          void handleIncomingData(event.data);
        };

        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        signalingWebSocket.send(JSON.stringify(peerConnection.localDescription));
      };
    }

    function registerControls() {
      if (controlsBound) {
        return;
      }
      controlsBound = true;

      screenEl.addEventListener("mousemove", (event) => {
        void sendControl({
          type: CONTROL_TYPES.mouseMove,
          x: event.offsetX,
          y: event.offsetY
        });
      });

      screenEl.addEventListener("click", (event) => {
        void sendControl({
          type: CONTROL_TYPES.mouseClick,
          x: event.offsetX,
          y: event.offsetY,
          button: "left"
        });
      });

      window.addEventListener("keydown", (event) => {
        const activeTag = document.activeElement ? document.activeElement.tagName : "";
        if (activeTag === "INPUT" || activeTag === "TEXTAREA") {
          return;
        }
        void sendControl({
          type: CONTROL_TYPES.keypress,
          key: event.key
        });
      });
    }

    function toggleStorage(forceOpen) {
      const shouldOpen = typeof forceOpen === "boolean"
        ? forceOpen
        : !storageDrawer.classList.contains("open");
      storageDrawer.classList.toggle("open", shouldOpen);
      storageDrawer.setAttribute("aria-hidden", (!shouldOpen).toString());
      if (shouldOpen) {
        if (isConnected) {
          void requestRemoteList(remoteCurrentPath);
        } else {
          setRemoteStatus("Connect to load files", "warn");
        }
      }
    }

    function joinRemotePath(base, name) {
      if (!base || base === ".") {
        return name;
      }
      const nameTrimmed = name.replace(/[\\/]+$/, "");
      if (!nameTrimmed) {
        return base;
      }
      const separator = base.includes("\\") ? "\\" : "/";
      const baseTrimmed = base.replace(/[\\/]+$/, "");
      const baseCompare = baseTrimmed.toLowerCase();
      const nameCompare = nameTrimmed.toLowerCase();
      if (baseCompare === nameCompare || baseCompare.endsWith(`${separator}${nameCompare}`)) {
        return base;
      }
      if (base.endsWith("/") || base.endsWith("\\")) {
        return `${base}${nameTrimmed}`;
      }
      return `${base}${separator}${nameTrimmed}`;
    }

    function getParentPath(path) {
      if (!path || path === ".") {
        return ".";
      }
      const trimmed = path.replace(/[\\/]+$/, "");
      if (!trimmed) {
        return ".";
      }
      if (trimmed.length === 2 && trimmed.endsWith(":")) {
        return ".";
      }
      const separator = trimmed.includes("\\") ? "\\" : "/";
      const parts = trimmed.split(/[\\/]/);
      if (parts.length <= 1) {
        return trimmed;
      }
      if (parts.length === 2 && parts[0].endsWith(":")) {
        return `${parts[0]}${separator}`;
      }
      return parts.slice(0, -1).join(separator);
    }

    function formatBytes(value) {
      if (value === null || value === undefined) {
        return "-";
      }
      const units = ["B", "KB", "MB", "GB", "TB"];
      let size = Number(value);
      let unitIndex = 0;
      while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex += 1;
      }
      return `${size.toFixed(size < 10 && unitIndex > 0 ? 1 : 0)} ${units[unitIndex]}`;
    }

    async function requestRemoteList(path) {
      if (!ensureChannelOpen()) {
        setRemoteStatus("Data channel not ready", "warn");
        return;
      }
      remoteCurrentPath = path || ".";
      remotePathInput.value = remoteCurrentPath;
      setRemoteStatus("Loading...", "warn");
      try {
        const message = await encodeOutgoing({
          action: "list_files",
          path: remoteCurrentPath
        });
        controlChannel.send(message);
      } catch (error) {
        setRemoteStatus(`E2EE error: ${error.message}`, "bad");
      }
    }

    async function requestDownload(path) {
      if (!ensureChannelOpen()) {
        setDownloadStatus("Data channel not ready", "warn");
        return;
      }
      pendingDownload = {
        path,
        name: getBaseName(path)
      };
      setDownloadStatus(`Downloading ${pendingDownload.name}`, "warn");
      try {
        const message = await encodeOutgoing({
          action: "download",
          path
        });
        controlChannel.send(message);
      } catch (error) {
        setDownloadStatus(`E2EE error: ${error.message}`, "bad");
        pendingDownload = null;
      }
    }

    function handleFileList(entries) {
      remoteFileList.textContent = "";
      if (!entries.length) {
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.colSpan = 3;
        cell.className = "empty-state";
        cell.textContent = "Empty folder";
        row.appendChild(cell);
        remoteFileList.appendChild(row);
        setRemoteStatus("Folder is empty", "warn");
        return;
      }

      const sorted = entries.slice().sort((a, b) => {
        if (a.is_dir !== b.is_dir) {
          return a.is_dir ? -1 : 1;
        }
        return a.name.localeCompare(b.name);
      });

      sorted.forEach((entry) => {
        const row = document.createElement("tr");
        const nameCell = document.createElement("td");
        const sizeCell = document.createElement("td");
        const actionCell = document.createElement("td");

        if (entry.is_dir) {
          const nameButton = document.createElement("button");
          nameButton.type = "button";
          nameButton.className = "entry-link";
          nameButton.textContent = entry.name;
          nameButton.addEventListener("click", () => {
            void requestRemoteList(joinRemotePath(remoteCurrentPath, entry.name));
          });
          nameCell.appendChild(nameButton);

          const openButton = document.createElement("button");
          openButton.type = "button";
          openButton.className = "ghost small";
          openButton.textContent = "Open";
          openButton.addEventListener("click", () => {
            void requestRemoteList(joinRemotePath(remoteCurrentPath, entry.name));
          });
          actionCell.appendChild(openButton);
          sizeCell.textContent = "-";
        } else {
          const nameSpan = document.createElement("span");
          nameSpan.className = "entry-file";
          nameSpan.textContent = entry.name;
          nameCell.appendChild(nameSpan);

          const downloadButton = document.createElement("button");
          downloadButton.type = "button";
          downloadButton.className = "secondary small";
          downloadButton.textContent = "Download";
          downloadButton.addEventListener("click", () => {
            void requestDownload(joinRemotePath(remoteCurrentPath, entry.name));
          });
          actionCell.appendChild(downloadButton);
          sizeCell.textContent = formatBytes(entry.size);
        }

        row.appendChild(nameCell);
        row.appendChild(sizeCell);
        row.appendChild(actionCell);
        remoteFileList.appendChild(row);
      });

      setRemoteStatus(`Loaded ${entries.length} item(s)`, "ok");
    }

    function getBaseName(path) {
      const parts = path.split(/[\\/]/);
      return parts[parts.length - 1] || "download";
    }

    function addDownloadEntry(name) {
      const stamp = new Date().toISOString().slice(11, 16);
      const item = document.createElement("li");
      item.textContent = `${name} at ${stamp}`;

      const emptyItem = downloadList.querySelector(".empty-state");
      if (emptyItem) {
        downloadList.textContent = "";
      }
      downloadList.prepend(item);
    }

    function saveBase64File(base64, filename) {
      const cleaned = base64.replace(/\s+/g, "");
      const binary = atob(cleaned);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      const blob = new Blob([bytes]);
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = filename || "download";
      document.body.appendChild(link);
      link.click();
      link.remove();
      URL.revokeObjectURL(url);
    }

    function handleError(errorPayload) {
      const message = errorPayload.message || "Unknown error";
      if (pendingDownload) {
        setDownloadStatus(message, "bad");
        pendingDownload = null;
      } else {
        setRemoteStatus(message, "bad");
      }
    }

    async function handleIncomingData(data) {
      try {
        const message = await decodeIncoming(data);
        handleDataChannelMessage(message);
      } catch (error) {
        const reason = error && error.message ? error.message : "E2EE failure";
        setStatus(reason, "bad");
        if (pendingDownload) {
          setDownloadStatus(reason, "bad");
          pendingDownload = null;
        } else {
          setRemoteStatus(reason, "bad");
        }
      }
    }

    function handleDataChannelMessage(message) {
      if (typeof message !== "string") {
        return;
      }
      let parsed = null;
      try {
        parsed = JSON.parse(message);
      } catch (error) {
        parsed = null;
      }

      if (parsed) {
        if (parsed.error) {
          handleError(parsed.error);
          return;
        }
        if (Array.isArray(parsed.files)) {
          handleFileList(parsed.files);
          return;
        }
      }

      if (!pendingDownload) {
        setDownloadStatus("Unexpected download payload", "warn");
        return;
      }
      try {
        saveBase64File(message, pendingDownload.name);
        addDownloadEntry(pendingDownload.name);
        setDownloadStatus(`Saved ${pendingDownload.name}`, "ok");
      } catch (error) {
        setDownloadStatus("Failed to save file", "bad");
      } finally {
        pendingDownload = null;
      }
    }

    function updateDrawerOffset() {
      const hud = document.getElementById("hud");
      if (!hud) {
        return;
      }
      const hudRect = hud.getBoundingClientRect();
      const gap = 12;
      const minTop = 16;
      const maxTop = Math.max(minTop, window.innerHeight - 220);
      const nextTop = Math.min(Math.max(minTop, hudRect.bottom + gap), maxTop);
      storageDrawer.style.top = `${nextTop}px`;
    }

    interactionToggle.addEventListener("change", updateInteractionMode);

    if (e2eeKeyInput) {
      e2eeKeyInput.addEventListener("input", () => {
        const value = e2eeKeyInput.value;
        if (value) {
          sessionStorage.setItem(E2EE_STORAGE_KEY, value);
        } else {
          sessionStorage.removeItem(E2EE_STORAGE_KEY);
        }
        e2eeContext = null;
        if (isConnected) {
          setStatus("E2EE key updated, reconnect", "warn");
        }
      });
    }

    document.getElementById("connectButton").addEventListener("click", connect);

    storageToggle.addEventListener("click", () => {
      updateDrawerOffset();
      toggleStorage();
    });
    storageClose.addEventListener("click", () => toggleStorage(false));

    document.getElementById("remoteGo").addEventListener("click", () => {
      const nextPath = remotePathInput.value.trim() || ".";
      void requestRemoteList(nextPath);
    });

    document.getElementById("remoteUp").addEventListener("click", () => {
      void requestRemoteList(getParentPath(remoteCurrentPath));
    });

    document.getElementById("remoteRefresh").addEventListener("click", () => {
      void requestRemoteList(remoteCurrentPath);
    });

    remotePathInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        void requestRemoteList(remotePathInput.value.trim() || ".");
      }
    });

    window.addEventListener("resize", updateDrawerOffset);
    updateDrawerOffset();
  </script>
=======
  <script src="app.js" defer></script>
>>>>>>> c4e2918e9de6745a3288236346c012c4da4d4a7e
</body>
</html>
